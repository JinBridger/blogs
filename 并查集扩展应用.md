<!--
 * @Author: JinBridge
 * @Date: 2021-10-02 20:52:34
 * @LastEditors: JinBridge
 * @LastEditTime: 2022-02-26 16:22:33
 * Copyright (c) 2022 by JinBridge, All Rights Reserved. 
-->
# 并查集扩展应用
## 边带权的并查集
有些时候我们需要维护不重叠集合内元素的距离，此时便引入了边带权的并查集。

实际上，边带权的并查集相当于是一个无向图组成的森林。

例题：
```
有一个划分成 N 列的星际战场，各列依次编号为 1, 2, ... N .有 N 艘战舰，也依次编号为 1, 2, ... N .其中第 i 号战舰处于第 i 列。
有 M 条指令，每条指令为以下两种格式之一：
1. M i j 表示让第 i 号战舰所在列的全部战舰保持原有顺序，接在第 j 号战舰所在列的尾部。
2. C i j 表示询问第 i 号与第 j 号战舰是否处在同一列中，如果处于同一列，则输出它们之间的战舰数。( NOI 2002 / Luogu P1196)
```

显然的，这些战舰组成了不重叠的集合，我们在维护这些战舰的集合关系的同时，还要维护它们之间的距离。很明显，每条战舰之间的距离为 $1$ .因此两条战舰之间的距离便是它们与对前方战舰的距离之差减一。

定义 $d[i]$ 表示第 $i$ 条战舰与其所在列战舰之间的距离。初始化 $d[i] = 0$ , 进行合并时，令接在后面的战舰的 $d[i]$ 等于前一个元素所在列的战舰数 $size[i]$ .通过维护 $d$ 与 $size$ 数组实现带权并查集。

边带权并查集的伪代码：

$\textbf{GET(x):}$

$1\ \ \ \ \textbf{if}\ \ x = fa[x]$

$2\ \ \ \ \ \ \ \ \textbf{return} x$

$3\ \ \ \ root \leftarrow GET(fa[x])$

$4\ \ \ \ do \  something \  to \  d[x]$

$5\ \ \ \ fa[x] \leftarrow root$

$6\ \ \ \ \textbf{return}\ \ fa[x]$



$\textbf{MERGE(x, y):}$

$1\ \ \ \ x \leftarrow GET(x)$

$2\ \ \ \ y \leftarrow GET(y)$

$3\ \ \ \ fa[x] \leftarrow y$

$4\ \ \ \ do \  something \  to \  d[x]$

## 扩展域的并查集

扩展域的并查集相对难理解一些。一个显著特点就是 __拆点__ ，通过将一个点拆成多个点从而维护多种属性。这也是扩展域这个名字的意思：将一个点从原来的一个域扩展出来多个域。

比如说一个对象 $x$ 如果属性是 $a,b$ 中的一种，那么我们就将 $x$ 拆成 $x_a,x_b$ 两个域来表示它是这两种属性的哪一种。

以 NOIp 2010 关押罪犯为例题:

```
某城有两座监狱，关押 N 名罪犯，这 N 名罪犯之间互有仇恨，如果将互相仇恨值为 a 的两名罪犯关押至同一监狱，就会发生影响为 a 的不良事件，为了使发生的不良事件的最大影响最小，请你设计方案关押这些罪犯。
```

显然每个罪犯要么关押在 A 监狱，要么关押在 B 监狱。符合我们刚才所说的属性是 $a,b$ 中的一种。我们将每个罪犯 $x$ 拆为 $x_A,x_B$ .

以输入样例为例，我们得到这样一张图

![1.png](Images/并查集扩展应用/1.png)

由贪心的思想可以得到，我们应当尽量把仇恨值大的罪犯分开关押，因此我们排序。然后可以看到，应该将一号与二号分开关押，于是我们这样连接：

![2.png](Images/并查集扩展应用/2.png)

其中两条线分别代表两种方案，一个是把 $1$ 号关在 $A$ 把 $2$ 号关在 $B$ , 另一个是把 $2$ 号关在 $A$ 而把 $1$ 号关在 $B$ 。
以此类推，最终得到

![3.png](Images/并查集扩展应用/3.png)

如果我们再进行下去，将 $2$ 与 $3$ 对应连接，那么两条线就会合为整体，而这样就会失去意义，所以答案就是 $3512$ .